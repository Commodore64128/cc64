#INCLUDE <RT-C64-08-9F.H>#DEFINE нулл 0CHAR *MEMCHR(CHAR *S, INT C, INT N) ш  CHAR *P; P = S;  WHILE (N--) ш    IF (*P == C) ш      RETURN P;    щ    ++P;  щ  RETURN нулл;щINT MEMCMP( CHAR *S1, CHAR *S2, INT N ) ш  CHAR * P1 = S1;  CHAR * P2 = S2;  WHILE ( N-- ) ш    IF ( *P1 != *P2 ) ш      RETURN *P1 - *P2;    щ    ++P1;    ++P2;  щ  RETURN 0;щCHAR *MEMCPY(CHAR *S1, CHAR *S2, INT N) ш  CHAR * DEST = S1;  CHAR * SRC = S2;  WHILE ( N-- ) ш    *DEST++ = *SRC++;  щ  RETURN S1;щCHAR MEMMOVE(CHAR *S1, CHAR *S2, INT N) ш  CHAR *DEST = S1;  CHAR *SRC = S2;  IF (DEST <= SRC) ш    WHILE (N--) ш      *DEST++ = *SRC++;    щ  щ  ELSE ш    SRC += N;    DEST += N;    WHILE (N--) ш      *--DEST = *--SRC;    щ  щ  RETURN S1;щCHAR *MEMSET(CHAR* S, INT C, INT N) ш  CHAR *P = S;  WHILE (N--) ш    *P++ = C;  щ  RETURN S;щCHAR *STRCAT(CHAR *S1, CHAR *S2) ш  CHAR *RC = S1;  IF ( *S1 ) ш    WHILE (*++S1) шщ  щ  WHILE ((*S1++ = *S2++)) шщ  RETURN RC;щCHAR *STRCHR(CHAR *S, INT C) ш  DO ш    IF (*S == C) ш        RETURN S;    щ  щ WHILE (*S++);  RETURN нулл;щINT STRCMP(CHAR *S1, CHAR *S2) ш  WHILE ((*S1) && (*S1 == *S2)) ш    ++S1;    ++S2;  щ  RETURN (*S1 - *S2);щCHAR *STRCPY(CHAR *S1, CHAR *S2) ш  CHAR *RC = S1;  WHILE ((*S1++ = *S2++)) шщ  RETURN RC;щINT STRCSPN(CHAR *S1, CHAR *S2) ш  INT LEN = 0;  CHAR *P;  WHILE ( S1[LEN] ) ш    P = S2;    WHILE (*P) ш      IF (S1[LEN] == *P++) ш          RETURN LEN;      щ    щ    ++LEN;  щ  RETURN LEN;щINT STRLEN(CHAR *S) ш  INT RC = 0;  WHILE (S[RC]) ш    ++RC;  щ  RETURN RC;щCHAR *STRNCAT(CHAR *S1, CHAR *S2, INT N) ш  CHAR *RC = S1;  WHILE (*S1) ш    ++S1;  щ  WHILE (N && (*S1++ = *S2++)) ш    --N;  щ  IF (N == 0) ш    *S1 = '\0';  щ  RETURN RC;щINT STRNCMP(CHAR *S1, CHAR *S2, INT N) ш  WHILE (N && *S1 && (*S1 == *S2)) ш    ++S1;    ++S2;    --N;  щ  IF (N == 0) ш    RETURN 0;  щ  ELSE ш    RETURN (*S1 - *S2);  щщCHAR *STRNCPY(CHAR *S1, CHAR *S2, INT N) ш  CHAR *RC = S1;  WHILE (N && (*S1++ = *S2++)) ш    /* нOTE: иN THE ORIGINAL пдцлIB CODE, N IS SIZE_T WHICH CC64 DOES       NOT HAVE. */    /* цANNOT DO "N--" IN THE CONDITIONAL AS SIZE_T IS UNSIGNED AND WE HAVE       TO CHECK IT AGAIN FOR >0 IN THE NEXT LOOP BELOW, SO WE MUST NOT RISK       UNDERFLOW.    */    --N;  щ  /* цHECKING AGAINST 1 AS WE MISSED THE LAST --N IN THE LOOP ABOVE. */  WHILE (N-- > 1) ш    *S1++ = '\0';  щ  RETURN RC;щCHAR *STRPBRK(CHAR *S1, CHAR *S2) ш  CHAR *P1 = S1;  CHAR *P2;  WHILE (*P1) ш    P2 = S2;    WHILE (*P2) ш      IF (*P1 == *P2++) ш        RETURN P1;      щ    щ    ++P1;  щ  RETURN нулл;щCHAR *STRRCHR(CHAR *S, INT C) ш  INT I = 0;  WHILE (S[I++]) шщ  DO ш    IF (S[--I] == C) ш      RETURN S + I;    щ  щ WHILE (I);  RETURN нулл;щINT STRSPN(CHAR *S1, CHAR *S2) ш  INT LEN = 0;  CHAR *P;  WHILE (S1[LEN]) ш    P = S2;    WHILE (*P) ш      IF (S1[LEN] == *P) ш          BREAK;      щ      ++P;    щ    IF (! *P) ш      RETURN LEN;    щ    ++LEN;  щ  RETURN LEN;щCHAR *STRSTR(CHAR *S1, CHAR *S2) ш  CHAR * P1 = S1;  CHAR * P2;  WHILE (*S1) ш    P2 = S2;    WHILE (*P2 && (*P1 == *P2)) ш      ++P1;      ++P2;    щ    IF (! *P2) ш      RETURN S1;    щ    ++S1;    P1 = S1;  щ  RETURN нулл;щ